# IS218 Midterm - Calculator Project  
#### Sharon Oh 
This midterm is for the course IS218 during the Fall 2024 semester at the New Jersey Institute of Technology. The midterm project requires us to develop an advanced calculator application using Python, Ubuntu, WSL, GitHub, and other knowledge we acquired from the previous lectures during the course. 

#### The video that demos this calculator application is here.

## Details and Setup
During the initial stages of the project, I started off with setting up the repo and downloading the necessary packages to ensure I had everything prepared. I first created the repository in GitHub and connected it to my local repository so that all my changes would sync up to the GitHub repo. I set up the necessary virtual environments after downloading them and activated it using "source my_env/bin/activate" so that the program would be able to run on this particular environment. I downloaded necessary packages/libraries/test such as pandas, pytest, etc to prepare the program for the different functions that will utilize those external downloads. At the initial stages, I made sure to freeze the requirements and transfer fundamental configuration files such as the logging.conf, .pylintrc, and pytest.ini files to name a few. Doing all of these smaller steps set up the program so that I could then work on the REPL interface and the plugin system.  

## Design Patterns, REPL Interface, and Plugins: 
The command-line interface uses REPL which is the read, evaluate, print loop to process user inputs from the command terminal and enacts direct interaction with the program. Users can utilize the plugin system that dynamically loads at the start of the program and allows for the flexible usage of various commands including both arithemtic commands and general program commands. For example, some plugins in the program include: add, subtract, multiple, divide, greet, menu, exit. The "menu" command can be used to list all the other available plugins in the calculator program to enable accessibility by the users. The main design pattern used for this application was the command pattern and a plugin system that allowed for the creation of objects for each particular operation such as add or subtract, which kept everything organized. I kept all of the arithematic commands in a separate file in the separate command folder that included functions like AddCommand or SubtractCommand. I utilized plugins to organize the execution of these operations which called from the command folder. Therefore, the majority of the action was occuring not amongst the plugin files, but in the command/__init__.py file. Additionally, I have a calculator folder with a file that defines the class Calculator which is used in my main app/__init__.py file. In this file, there is the "App"" class that is defined with various functions that contribute to the REPL process. The user input is read by the "start" function and since the calculator is instantiated and called in this method, the plugins dealing with the operations are executed. Since these plugins are simply executing the commands in the commands folder, essentially the design of the application is very tightly related to each other. To backtrack a little bit, the user input is read through the app/__init__.py file (by the "App" class) and has the plugins registered based on the input of the user. The plugins are connected to the mathematical function within the AddCommand, SubtractCommand, etc and once that command runs, the result is outputted into the terminal. There are exception cases that I added in this design pattern to catch any invalid user inputs. This makes the calculator interactive and engages the user with the functionality of the calculator. The use of a interconnected design system that is structured in an organized manner, through utilizing only necessary files and a flexibile plugin system, users can easily utilize all of the available commands and features. 


## Environment Variables:
Environment variables were used to store secret or sensitive information through its key and value pairs. While perhaps unnecessary in the context of a calculator application, because there isn't really secretive information, it is useful to utilize as it offers a way of protection of important data. I used environment variables to keep track of sensitive information such as "DATABASE_USERNAME", "PASS_KEY", and "SETTING". Rather than hardcoding this information somewhere in the program, I placed it into an .env file and had the program just print off of it. I had to utilize a load_dotenv and create a separate function to load the environment variables from the operating system. This will all done in the class "App" method.

## Logging:
Throughout the program, I used logging to ensure that the program was running smoothly and that all the information was recorded down. I used various levels of logs, mainly "logging.info" and "logging.error" to record the messages that were generated by the program. It helped me keep track of the application and to better understand how the program flowed. The log was used in multiple areas of the program and was stored in its own private log folder/file. 

## Try/Catch/Exceptions:
Try/catch/exceptions were utilized to use LBYL and EAFP particularly to help with handling exceptions and errors that may arise in the code. It allows for specific responses and messages to be displayed to react to different types of errors that may occur during the program running. I utilized a try/catch/exception in the app/__init__.py file to catch any exceptions based on the user input from the terminal. This particular try/except usage determines if the input from the user is valid. They will try to check its validity and if it a valid input such as ("3 4 add"), the program will continue into the if statements that executes the command using the calculations. Yet, if the user does not type a valid input, the program will raise an exception that presents an error to terminal to notify the user that their input will not work. For example, if the user types in ("12 0 divide") or ("3 d subtract), both cases would result in the exception being thrown and present either a ValueError or ZeroDivisionError. This is useful because the program checks if the input is processable and then raises the appropriate error message if the input is not valid, leading to a clear and efficient program.


## Utilizing Pandas and History Management:
The calculation history is managed through pandas libraries which permits the users to load, clear, and save the history records through the interactive terminal. The user's calculation history needed to be saved and also recalled based on the user input. Pandas was used in conjunction with a csv file titled "history.csv" to be able to read and input the calculation histories from the user input and also back into the terminal. To utilize pandas, I downloaded the library first and imported pandas into the necessary files. Then, the program was created in a way that checks if the history.csv file exists. If it does exist already, meaning that there are previous calculations stored in the history, the new calculations that user will add will concatenate into the file. I orginally, wanted to use the append method, but came across an error stating that it was not compatible with future versions of pandas. If the history.csv has no content in it, the program will just store the new calculations that are added. If the history.csv file just does not exist, it will raise an error. The user has two choices to choose from regarding their history. These choices are listed at the beginning of the program when it is loaded: "clear" and "history". If they input "clear" into the terminal, the user clears everything in the history.csv file. If they input "history" into the terminal, they are able to see all of the history that the calculator program has. 

## Architectural Decisions 
Since this project entailed for a lot of parts such as having a REPL interface, plugins, pandas, logging, etc, I wanted to develop the program in an approach that organized the codes in an intuitive way. By organizing the commands by keeping all of it within one file (in the commands/__init__.py file) and structuring the history management code also in one file (in the history/__init__.py file), I had all of the feature's core functionalities located in one spot. The program produced a straightforward interface that simply took inputs from the user and processed what they had to an execution. In the "start" function within the app/__init__.py file, the program checks the input from the user and sees if it amongst any of the possible commands avaliable. If it is, it executes that command. For example, if I put in 3 4 add, the program would identify the add command and execute the command through the calculator that was imported at the beginning of that file. It would then be directed to the add plugin which is connected to the AddCommand, where the actual operation occurs. This similar idea  is applied to the rest of the features to establish consistency and unity in syntax and logic. 

## GitHub Actions 
GitHub Actions was used to ensure that the code passed all the required tests. The workflow of it was established in the yml file in the .github/workflows folder. The workflows processed smoothly, meaning that the program was functioning properly.


## Test Cases
To ensure that my program was running smoothly, I utilized pytest to achieve test coverage. Through using direct function calls within my test, to call and execute directly from the commands I created, I tested out 17 test cases. For each operation (add, subtract, multiply, divide), I created 3 test cases. This would test out what would happen in a normal input, where a user inputs two numbers and a command, and also an input where the user may accidentally input a letter instead. Moreover, another test case was also created for the divison function to test out a divison by zero situation. I also created test cases for the logging history and clearing history to ensure that they both work. When running pytest, I was able to achieve a satisfactory level of test coverage, and after testing each particular case, I was able to specifically see which cases passed or had an errors if applicable. The usability and functionality of my program was verified through these test cases. 